from pathlib import Path
from typing import Union, Literal, Tuple, get_args
import re


filetypes = Literal["midi", "full_midi", "flac", "full_flac", "mp4",
                    "full_video", "video", "aac", "full_audio", "audio"]

suffixes = Literal[".aac", ".flac", ".mp4", ".mid"]
suffixes_list: Tuple[suffixes, ...] = get_args(suffixes)


class PathUtils:
    """
    Contains various functions that help working with paths within the dataset.
    """

    def get_type(self, path: Path) -> filetypes:
        if self.is_full_midi(path):
            return "full_midi"
        elif self.is_valid_midi(path):
            return "midi"
        elif self.is_full_flac(path):
            return "full_flac"
        elif self.is_valid_flac(path):
            return "flac"
        elif path.suffix == ".mp4":
            if self.is_full_video(path):
                return "full_video"
            return "video"
        elif path.suffix == ".aac":
            if self.is_full_audio(path):
                return "full_audio"
            return "audio"

    @staticmethod
    def get_session_no(file: Path) -> Union[str, None]:
        """
        Get the session number from a given file in the format 01, 02, etc.
        """
        for i in file.stem.split("_"):
            if re.search(pattern="(^a|^v)\\d\\d$", string=i):
                return i[-2:]
        return None

    @staticmethod
    def get_date(file: Path) -> Union[str, None]:
        """
        Get the date from a given file in format yyyy_mm_dd.
        Raises an attribute error if a date cannot be found.
        """
        for i in file.stem.split("_"):
            if re.search(pattern="^\\d{4}-\\d{2}-\\d{2}$",
                         string=i):
                return i
        raise AttributeError("Date could not be identified from the given "
                             "file.")

    @staticmethod
    def is_full_audio(file: Path) -> bool:
        """
        Check whether a certain file is the full audio file as generated by
        extract_and_concat_audio.
        """

        return file.stem.split("_")[-1] == "full" and file.suffix == ".aac"

    @staticmethod
    def is_full_midi(file: Path) -> bool:
        """
        Check whether a file is a full midi file and not an individual part.
        """
        # TODO
        # Currently there is no script for concatenating midi files so all
        # are considered full.
        return file.suffix == ".mid"
#        return file.stem.split("_")[-1] == "full" and file.suffix == ".mid"

    @staticmethod
    def is_trimmed(file: Path) -> bool:
        """
        Check whether a file is a trimmed audio.
        """

        return file.stem.split("_")[-1] == "trimmed"

    @staticmethod
    def is_warmup(file: Path) -> bool:
        """
        Check if a file is from a warmup.
        """
        return file.stem.split("_")[0] == "warmup"

    def is_full_flac(self, file: Path) -> bool:
        """
        Check whether a file is a full flac recording of a session
        """
        return len(file.stem.split("_")) == 2 and \
            self.is_valid_flac(file=file) and \
            file.stem.split("_")[-1] == "full"

    @staticmethod
    def is_valid_flac(file: Path) -> bool:
        return file.suffix == ".flac"

    @staticmethod
    def is_valid_midi(file: Path) -> bool:
        """
        Check if a midi file is valid.
        """
        split_len = len(file.stem.split("_"))
        if split_len != 3:
            return False
        if not file.suffix == ".mid":
            return False
        return True

    @staticmethod
    def is_full_video(file: Path):
        """
        Check if a file is a full video file of a session
        """
        if file.suffix != ".mp4":
            return False

        split = file.stem.split("_")
        if "full" in split:
            return True
        return False

    @staticmethod
    def get_files_by_type(root: Path,
                          filetype: Union[suffixes]) -> list[Path]:
        """
        Return all files in the dataset of a certain type. The types should be
        found in file_suffixes.

        Parameters
        ----------
        root: where to start the recursive search
        filetype: .mid, .flac, etc.

        Returns list of Path objects
        -------
        """
        files = [Path(j) for j in root.rglob('*' + filetype)]
        return files
